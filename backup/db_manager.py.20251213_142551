# db_manager.py

import os
from sqlalchemy import create_engine, Column, Integer, String, DateTime
from sqlalchemy.orm import sessionmaker, declarative_base, Session
from datetime import datetime

# >>> НАЧАЛО БЛОКА: КОНФИГУРАЦИЯ БАЗЫ ДАННЫХ <<<
DB_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), "referral_orders.db")
DATABASE_URL = f"sqlite:///{DB_FILE}"

engine = create_engine(DATABASE_URL)

Base = declarative_base()  # SQLAlchemy 2.0+

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
# >>> КОНЕЦ БЛОКА: КОНФИГУРАЦИЯ БАЗЫ ДАННЫХ <<<


# >>> НАЧАЛО БЛОКА: ОПРЕДЕЛЕНИЕ МОДЕЛИ ТАБЛИЦЫ "orders" <<<
class Order(Base):
    """Модель для хранения заказов Ozon."""
    
    __tablename__ = "orders"
    
    # 1. Основные поля
    id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    order_id = Column(String, unique=False, index=True) # Номер заказа (не unique, так как может быть несколько товаров)
    posting_number = Column(String, unique=True, index=True) # Номер отправления (Должен быть уникальным для строки заказа/товара)
    status = Column(String) 
    created_at = Column(DateTime, default=datetime.utcnow) # ИСПРАВЛЕНО
    
    # 2. Поля для аналитики и пользователя
    buyer_id = Column(String, index=True) # ID покупателя (ключ для рефералов)
    price_amount = Column(String) 
    item_name = Column(String) 
    item_sku = Column(String) 
    quantity = Column(String) 
    
    # 3. Дополнительные поля (Исправлены типы)
    delivering_date = Column(String)
    in_process_at = Column(String)
    cluster_from = Column(String)
    cluster_to = Column(String)
    address = Column(String)
    
    sync_time = Column(DateTime, default=datetime.utcnow) # ИСПРАВЛЕНО
    
    currency_code = Column(String)
    articul = Column(String)
    buyer_paid = Column(String)
    shipping_cost = Column(String)
    is_redeemed = Column(String)
    price_before_discount = Column(String)
    discount_percent = Column(String) # ИСПРАВЛЕНО
    discount_rub = Column(String)
    promotion = Column(String)
    weight_kg = Column(String)
    norm_delivery_time = Column(String)
    shipping_evaluation = Column(String)
    shipping_warehouse = Column(String)
    delivery_region = Column(String)
    delivery_city = Column(String)
    delivery_method = Column(String)
    client_segment = Column(String)
    is_legal_entity = Column(String)
    payment_method = Column(String)
    
# >>> КОНЕЦ БЛОКА: ОПРЕДЕЛЕНИЕ МОДЕЛИ ТАБЛИЦЫ "orders" <<<


# >>> НАЧАЛО БЛОКА: ОПРЕДЕЛЕНИЕ МОДЕЛИ ТАБЛИЦЫ "customers" <<<
class Customer(Base):
    """Модель для хранения информации о клиентах Ozon."""
    
    __tablename__ = "customers"
    
    # Основные поля
    id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    buyer_id = Column(String, unique=True, index=True)  # ID покупателя (уникальный ключ)
    
    # Контактная информация
    name = Column(String)  # Имя клиента
    phone = Column(String)  # Телефон
    email = Column(String)  # Email
    
    # Адресная информация
    address = Column(String)  # Полный адрес
    delivery_region = Column(String)  # Регион доставки
    delivery_city = Column(String)  # Город доставки
    cluster_to = Column(String)  # Кластер доставки
    
    # Дополнительная информация
    client_segment = Column(String)  # Сегмент клиента
    is_legal_entity = Column(String)  # Юридическое лицо (да/нет)
    payment_method = Column(String)  # Способ оплаты
    
    # Статистика
    total_orders = Column(Integer, default=0)  # Общее количество заказов
    total_spent = Column(String, default="0")  # Общая сумма покупок
    
    # Временные метки
    first_order_date = Column(DateTime)  # Дата первого заказа
    last_order_date = Column(DateTime)  # Дата последнего заказа
    created_at = Column(DateTime, default=datetime.utcnow)  # Дата создания записи
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)  # Дата обновления
    
# >>> КОНЕЦ БЛОКА: ОПРЕДЕЛЕНИЕ МОДЕЛИ ТАБЛИЦЫ "customers" <<<


# >>> НАЧАЛО БЛОКА: ОПРЕДЕЛЕНИЕ МОДЕЛИ ТАБЛИЦЫ "participants" <<<
class Participant(Base):
    """Модель для хранения участников реферальной программы."""
    
    __tablename__ = "participants"
    
    # Основные поля
    id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    ozon_id = Column(String, unique=True, index=True)  # Ozon ID (уникальный ключ)
    telegram_id = Column(String, unique=True, index=True)  # Telegram ID (уникальный ключ)
    
    # Информация о пользователе
    name = Column(String)  # Имя / ник
    username = Column(String)  # Telegram username (с @)
    
    # Реферальная информация
    referrer_id = Column(String, index=True)  # ID пригласившего (ozon_id реферера)
    
    # Дополнительная информация
    language = Column(String)  # Язык пользователя
    
    # Временные метки
    registration_date = Column(DateTime, default=datetime.utcnow)  # Дата регистрации
    created_at = Column(DateTime, default=datetime.utcnow)  # Дата создания записи
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)  # Дата обновления
    
# >>> КОНЕЦ БЛОКА: ОПРЕДЕЛЕНИЕ МОДЕЛИ ТАБЛИЦЫ "participants" <<<


# >>> НАЧАЛО БЛОКА: ОПРЕДЕЛЕНИЕ МОДЕЛИ ТАБЛИЦЫ "sync_settings" <<<
class SyncSettings(Base):
    """Модель для хранения настроек синхронизации."""
    
    __tablename__ = "sync_settings"
    
    id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    key = Column(String, unique=True, index=True)  # Ключ настройки (например, "last_sync_time")
    value = Column(String)  # Значение настройки (храним как строку, парсим при использовании)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)  # Дата обновления
    
# >>> КОНЕЦ БЛОКА: ОПРЕДЕЛЕНИЕ МОДЕЛИ ТАБЛИЦЫ "sync_settings" <<<


# >>> НАЧАЛО БЛОКА: ФУНКЦИИ ВЗАИМОДЕЙСТВИЯ С БД <<<
def create_database():
    """Создает базу данных и все определенные таблицы."""
    Base.metadata.create_all(bind=engine)
    print(f"База данных успешно создана или обновлена: {DB_FILE}")

def get_db():
    """Генерирует сессию для взаимодействия с БД."""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def order_exists(db: Session, posting_number: str) -> bool:
    """Проверяет, существует ли заказ в базе данных по номеру отправления."""
    return db.query(Order).filter(Order.posting_number == posting_number).first() is not None

def customer_exists(db: Session, buyer_id: str) -> bool:
    """Проверяет, существует ли клиент в базе данных по buyer_id."""
    return db.query(Customer).filter(Customer.buyer_id == buyer_id).first() is not None

def get_customer(db: Session, buyer_id: str) -> Customer | None:
    """Получает клиента по buyer_id."""
    return db.query(Customer).filter(Customer.buyer_id == buyer_id).first()

def create_or_update_customer(db: Session, customer_data: dict) -> Customer:
    """Создает нового клиента или обновляет существующего."""
    # #region agent log
    import json
    try:
        with open(r'c:\telegram-ref-bot\.cursor\debug.log', 'a', encoding='utf-8') as f:
            log_entry = {"sessionId":"debug-session","runId":"run1","hypothesisId":"C","location":"db_manager.py:180","message":"create_or_update_customer entry","data":{"buyer_id":customer_data.get("buyer_id","")},"timestamp":int(datetime.now().timestamp()*1000)}
            f.write(json.dumps(log_entry, ensure_ascii=False) + '\n')
    except Exception as log_err:
        pass
    # #endregion
    buyer_id = customer_data.get("buyer_id")
    if not buyer_id:
        # #region agent log
        try:
            with open(r'c:\telegram-ref-bot\.cursor\debug.log', 'a', encoding='utf-8') as f:
                log_entry = {"sessionId":"debug-session","runId":"run1","hypothesisId":"C","location":"db_manager.py:184","message":"buyer_id missing error","data":{},"timestamp":int(datetime.now().timestamp()*1000)}
                f.write(json.dumps(log_entry, ensure_ascii=False) + '\n')
        except Exception as log_err:
            pass
        # #endregion
        raise ValueError("buyer_id обязателен для создания/обновления клиента")
    
    customer = get_customer(db, buyer_id)
    
    if customer:
        # Обновляем существующего клиента
        for key, value in customer_data.items():
            if hasattr(customer, key) and value is not None:
                setattr(customer, key, value)
        customer.updated_at = datetime.utcnow()
        # #region agent log
        try:
            with open(r'c:\telegram-ref-bot\.cursor\debug.log', 'a', encoding='utf-8') as f:
                log_entry = {"sessionId":"debug-session","runId":"run1","hypothesisId":"C","location":"db_manager.py:193","message":"Updating existing customer","data":{"buyer_id":buyer_id},"timestamp":int(datetime.now().timestamp()*1000)}
                f.write(json.dumps(log_entry, ensure_ascii=False) + '\n')
        except Exception as log_err:
            pass
        # #endregion
    else:
        # Создаем нового клиента
        customer = Customer(**customer_data)
        db.add(customer)
        # #region agent log
        try:
            with open(r'c:\telegram-ref-bot\.cursor\debug.log', 'a', encoding='utf-8') as f:
                log_entry = {"sessionId":"debug-session","runId":"run1","hypothesisId":"C","location":"db_manager.py:197","message":"Adding new customer to session","data":{"buyer_id":buyer_id},"timestamp":int(datetime.now().timestamp()*1000)}
                f.write(json.dumps(log_entry, ensure_ascii=False) + '\n')
        except Exception as log_err:
            pass
        # #endregion
    
    return customer

# >>> ФУНКЦИИ ДЛЯ РАБОТЫ С УЧАСТНИКАМИ РЕФЕРАЛЬНОЙ ПРОГРАММЫ <<<
def find_participant_by_ozon_id(ozon_id: str) -> dict | None:
    """Ищет участника по его Ozon ID. Возвращает словарь в формате совместимом с Google Sheets."""
    db = SessionLocal()
    try:
        participant = db.query(Participant).filter(Participant.ozon_id == str(ozon_id)).first()
        if participant:
            return {
                "ID участника": participant.ozon_id,
                "Имя / ник": participant.name or "",
                "Телеграм @": participant.username or "",
                "Ozon ID": participant.ozon_id,
                "ID пригласившего": participant.referrer_id or "",
                "Дата регистрации": participant.registration_date.strftime("%Y-%m-%d") if participant.registration_date else "",
                "Telegram ID": participant.telegram_id,
            }
        return None
    finally:
        db.close()

def find_participant_by_telegram_id(tg_id: int) -> dict | None:
    """Ищет участника по его Telegram ID. Возвращает словарь в формате совместимом с Google Sheets."""
    db = SessionLocal()
    try:
        participant = db.query(Participant).filter(Participant.telegram_id == str(tg_id)).first()
        if participant:
            return {
                "ID участника": participant.ozon_id,
                "Имя / ник": participant.name or "",
                "Телеграм @": participant.username or "",
                "Ozon ID": participant.ozon_id,
                "ID пригласившего": participant.referrer_id or "",
                "Дата регистрации": participant.registration_date.strftime("%Y-%m-%d") if participant.registration_date else "",
                "Telegram ID": participant.telegram_id,
            }
        return None
    finally:
        db.close()

def create_participant(
    tg_id: int,
    username: str | None,
    first_name: str | None,
    ozon_id: str,
    referrer_id: str | None = None,
    language: str | None = None,
) -> dict:
    """Создает нового участника в базе данных. Возвращает словарь в формате совместимом с Google Sheets."""
    db = SessionLocal()
    try:
        # Проверяем, не существует ли уже участник
        existing = db.query(Participant).filter(
            (Participant.ozon_id == str(ozon_id)) | (Participant.telegram_id == str(tg_id))
        ).first()
        
        if existing:
            # Если участник уже существует, возвращаем его данные
            return {
                "ID участника": existing.ozon_id,
                "Имя / ник": existing.name or "",
                "Телеграм @": existing.username or "",
                "Ozon ID": existing.ozon_id,
                "ID пригласившего": existing.referrer_id or "",
                "Дата регистрации": existing.registration_date.strftime("%Y-%m-%d") if existing.registration_date else "",
                "Telegram ID": existing.telegram_id,
            }
        
        # Создаем нового участника
        tg_username = f"@{username}" if username else ""
        name = first_name or ""
        
        participant = Participant(
            ozon_id=str(ozon_id),
            telegram_id=str(tg_id),
            name=name,
            username=tg_username,
            referrer_id=str(referrer_id) if referrer_id else None,
            language=language,
            registration_date=datetime.utcnow(),
        )
        
        db.add(participant)
        db.commit()
        
        return {
            "ID участника": participant.ozon_id,
            "Имя / ник": participant.name,
            "Телеграм @": participant.username,
            "Ozon ID": participant.ozon_id,
            "ID пригласившего": participant.referrer_id or "",
            "Дата регистрации": participant.registration_date.strftime("%Y-%m-%d"),
            "Telegram ID": participant.telegram_id,
        }
    except Exception as e:
        db.rollback()
        raise e
    finally:
        db.close()
# >>> КОНЕЦ БЛОКА: ФУНКЦИИ ДЛЯ РАБОТЫ С УЧАСТНИКАМИ <<<

# >>> ФУНКЦИИ ДЛЯ РАБОТЫ С НАСТРОЙКАМИ СИНХРОНИЗАЦИИ <<<
def get_last_sync_timestamp() -> datetime | None:
    """Возвращает время последней успешной синхронизации из базы данных."""
    db = SessionLocal()
    try:
        setting = db.query(SyncSettings).filter(SyncSettings.key == "last_sync_time").first()
        if setting and setting.value:
            try:
                return datetime.strptime(setting.value, "%Y-%m-%d %H:%M:%S")
            except ValueError:
                return None
        return None
    finally:
        db.close()

def set_last_sync_timestamp(timestamp: datetime):
    """Записывает время последней успешной синхронизации в базу данных."""
    db = SessionLocal()
    try:
        setting = db.query(SyncSettings).filter(SyncSettings.key == "last_sync_time").first()
        timestamp_str = timestamp.strftime("%Y-%m-%d %H:%M:%S")
        
        if setting:
            setting.value = timestamp_str
            setting.updated_at = datetime.utcnow()
        else:
            setting = SyncSettings(key="last_sync_time", value=timestamp_str)
            db.add(setting)
        
        db.commit()
        print(f"Время синхронизации обновлено до: {timestamp_str}")
    except Exception as e:
        db.rollback()
        print(f"Ошибка записи времени синхронизации: {e}")
        raise e
    finally:
        db.close()
# >>> КОНЕЦ БЛОКА: ФУНКЦИИ ДЛЯ РАБОТЫ С НАСТРОЙКАМИ СИНХРОНИЗАЦИИ <<<

# >>> КОНЕЦ БЛОКА: ФУНКЦИИ ВЗАИМОДЕЙСТВИЯ С БД <<<


if __name__ == "__main__":
    create_database()